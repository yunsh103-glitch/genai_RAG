# GenAI RAG Chatbot 프로젝트 상세 문서

## 1. 개요 (Overview)
이 프로젝트는 **Next.js 15**와 **Google Gemini API**를 기반으로 구축된 **Serverless RAG(Retrieval-Augmented Generation)** 채팅 애플리케이션입니다. Google의 **Gemini File Search** 기능을 활용하여 사용자가 업로드한 문서를 기반으로 정확하고 근거 있는 답변을 제공하며, 관리자 페이지를 통해 문서 및 시스템 프롬프트를 동적으로 관리할 수 있습니다.

---

## 2. 개발 스펙 (Development Specifications)

### 2.1 핵심 기술 스택
- **Framework**: Next.js 15 (App Router 사용)
- **Language**: TypeScript (v5.9)
- **Runtime**: Node.js (Serverless Function)
- **AI Engine**: Google Gemini API via `@google/genai` SDK
- **RAG Engine**: Gemini File Search (Semantic Retrieval)
- **Styling**: Tailwind CSS 4, Tailwind Merge, CLSX
- **Database**: Vercel KV (채팅 히스토리 및 단순 설정 저장용)
- **Deployment**: Vercel

### 2.2 주요 라이브러리 및 버전
- **Core**: `next` (15.5.9), `react` (19.2.3)
- **AI**: `@google/genai` (1.34.0), `ai` (6.0.7)
- **UI Components**: `@radix-ui/*` (Dialog, Select, Slot 등), `lucide-react` (Icons)
- **Animation**: `framer-motion` (12.23.26)
- **Markdown**: `react-markdown` (10.1.0), `remark-gfm` (4.0.1)

---

## 3. 시스템 구조 (System Architecture)

### 3.1 아키텍처 개요
시스템은 크게 **사용자 인터페이스(Frontend)**, **서버리스 API(Backend)**, **외부 AI 서비스(Google Gemini)** 세 부분으로 구성됩니다.

1.  **Frontend (Next.js App Router)**:
    -   `/chat`: 실시간 스트리밍 대화 인터페이스.
    -   `/admin`: 파일 업로드, 스토어 관리, 프롬프트 설정 제어 대시보드.
2.  **Backend (Next.js API Routes)**:
    -   API Key 노출을 방지하기 위한 보안 계층 역할.
    -   클라이언트의 요청을 받아 Google Gemini API와 통신하고 결과를 스트리밍 또는 JSON으로 반환.
3.  **AI Services**:
    -   **Gemini Model**: 텍스트 생성 및 추론 (기본: `gemini-2.5-flash` 등).
    -   **File Search Store**: 문서 임베딩 및 검색 인덱스 저장소.

### 3.2 데이터 흐름 (Data Flow)
1.  **채팅 흐름 (RAG Mode)**:
    -   사용자 메시지 입력 → `/api/chat` 요청 전송.
    -   서버에서 현재 설정된 시스템 프롬프트 및 RAG Store ID 로드.
    -   Gemini API에 `user message` + `tools: [fileSearch]` 요청.
    -   Gemini가 관련 문서를 검색(Retrieval)하고 Grounding(근거) 기반 답변 생성.
    -   답변과 인용(Citation) 정보를 클라이언트에 반환 (Streaming 지원 가능 구조).

2.  **파일 업로드 흐름**:
    -   관리자 페이지에서 파일 선택 → `/api/files` 요청.
    -   서버 `middleware` 등을 거쳐 Google File API를 통해 파일을 업로드 (`uploadFile`).
    -   업로드된 파일을 특정 `File Search Store`에 연결 (`fileSearchStores.create` 또는 업데이트).
    -   Indexing 상태 대기 (Processing → Active).

---

## 4. 핵심 기능 (Core Features)

### 4.1 채팅 인터페이스 (`/chat`)
-   **RAG 기반 답변**: 업로드된 문서 내용을 바탕으로 정확한 사실 기반의 답변을 생성합니다.
-   **인용(Citation) 표시**: 답변의 출처가 되는 문서의 일부분을 UI에 명시하여 신뢰도를 높입니다.
-   **실시간 응답**: 타이핑 효과를 위한 실시간 렌더링을 지원합니다.
-   **히스토리 관리**: Vercel KV를 사용하여 이전 대화 내용을 저장하고 불러옵니다.
-   **Markdown 렌더링**: 코드 블록, 표, 리스트 등 풍부한 텍스트 서식을 지원합니다.

### 4.2 관리자 대시보드 (`/admin`)
-   **스토어(Store) 관리**: RAG 검색의 단위인 'Store'를 생성하고 삭제할 수 있습니다. 주제별로 스토어를 분리하여 운영 가능합니다.
-   **파일(File) 관리**: PDF, DOCX, TXT 등 다양한 포맷의 문서를 업로드하고 삭제할 수 있습니다.
-   **시스템 프롬프트 설정**: AI의 페르소나, 답변 스타일, 제약 사항을 UI에서 직접 수정하여 적용할 수 있습니다. (예: 채용 도우미, 기술 문서 봇 등)
-   **모델 선택**: 사용할 Gemini 모델 버전을 드롭다운으로 선택하여 동적으로 변경할 수 있습니다.

---

## 5. 상세 구현 내용 (Implementation Details)

### 5.1 AI 클라이언트 설정 (`lib/gemini.ts`)
-   `@google/genai` 패키지의 `GoogleGenAI` 클래스를 인스턴스화하여 사용합니다.
-   API Key는 `process.env.GOOGLE_GENERATIVE_AI_API_KEY` 환경변수에서 로드합니다.

### 5.2 채팅 API 구현 (`app/api/chat/route.ts`)
-   **요청 처리**: 클라이언트로부터 `message`, `storeId`, `history`를 수신합니다.
-   **Tool 설정**: `storeId`가 유효한 경우 `config.tools` 속성에 `fileSearch` 도구를 주입하여 RAG 모드를 활성화합니다.
-   **프롬프트 주입**: 관리자 설정에서 저장된 `systemInstruction`을 `config.systemInstruction`에 주입하여 AI의 행동을 제어합니다.
-   **응답 처리**: `generateContent` 메서드를 호출하고, 반환된 `text`와 `groundingMetadata`(인용 정보)를 클라이언트에 전달합니다.

### 5.3 파일 및 스토어 관리 (`app/api/files`, `app/api/stores`)
-   Google GenAI API의 `fileManager`와 `fileSearchStores` 모듈을 사용합니다.
-   파일 업로드 시 MIME 타입을 자동 감지하여 처리합니다.
-   업로드된 파일은 Google의 서버에 저장되며, 특정 Store에 연결되어야 검색 대상이 됩니다.

### 5.4 설정 저장소 (`lib/settings.ts`, `data/settings.json`)
-   시스템 프롬프트, 선택된 모델, 활성화된 RAG Store ID 등 전역 설정을 관리합니다.
-   초기 구현은 로컬 JSON 파일 또는 Vercel KV 등을 사용하여 설정을 영속화합니다.

---

## 6. 보안 및 확장성 (Security & Scalability)

-   **API Key 보호**: 모든 Gemini API 호출은 Server-side(`app/api/*`)에서 이루어지므로 클라이언트에 API Key가 노출되지 않습니다.
-   **환경 변수 관리**: 민감한 정보(API Key, DB 접속 정보 등)는 `.env.local`을 통해 관리됩니다.
-   **Serverless 구조**: 트래픽에 따라 자동으로 스케일링되는 Next.js API Routes를 사용하여 별도의 서버 인프라 관리가 필요 없습니다.
